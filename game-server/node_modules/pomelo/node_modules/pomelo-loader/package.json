{
  "name": "pomelo-loader",
  "version": "0.0.4",
  "dependencies": {},
  "devDependencies": {
    "mocha": ">=0.0.1",
    "should": ">=0.0.1"
  },
  "contributors": [
    {
      "name": "* Yongchang Zhou",
      "email": "changchang005@gmail.com"
    }
  ],
  "readme": "#pomelo-loader - loader module for pomelo\npomelo中使用Convention over Configuration的形式管理工程目录，不同的功能按约定放在不同的目录下。pomelo-loader为pomelo提供了按目录加载模块的功能。\n\npomelo-rpc可以批量加载指定目录下的模块，挂到一个空对象下返回（但不会递归加载子目录），同时提供模块命名机制。\n\n+ Tags: node.js\n\n##规则说明\n模块命名\n\n模块默认以文件名为名。如：加载lib/a.js后，返回的结果为：{a: require('./lib/a')}。\n\n如果模块中定义了name属性，则会以name作为模块的名称。如：\n```javascript\na.js\nexports.name = 'test';\n```\n返回的结果为：{test: require('./lib/a')}\n\n模块定义\n\n如果模块以function的形式暴露出去，则这个function会被当作构造模块实例的工厂方法，Loader会调用这个function获取模块的实例，同时可以传递一个context参数作为工厂方法的参数。其他情况则直接把加载到的模块返回。\n```javascript\nmodule.exports = function(context) {\n\treturn {};\t// return some module instance\t\n};\n```\n\n##安装\n```\nnpm install pomelo-loader\n```\n\n##用法\n``` javascript\nvar Loader = require('pomelo-loader');\n\nvar res = Loader.load('.');\nconsole.log('res: %j', res);\n``` \n模块定义成函数，加载\n\n##API\n###Loader.load(path, context)\n加载path目录下所有模块。如果模本身是一个function，则把这个function作为获取模块的工厂方法，通过调用这个方法获取到模块实例;否则直接返回加载到的模块。\n####参数\n+ path 加载的目录\n+ context 如果通过工厂方法加载模块，会将该参数作为初始化参数传给工厂方法。\n",
  "readmeFilename": "README.md",
  "_id": "pomelo-loader@0.0.4",
  "description": "pomelo中使用Convention over Configuration的形式管理工程目录，不同的功能按约定放在不同的目录下。pomelo-loader为pomelo提供了按目录加载模块的功能。",
  "_from": "pomelo-loader@0.0.4"
}
