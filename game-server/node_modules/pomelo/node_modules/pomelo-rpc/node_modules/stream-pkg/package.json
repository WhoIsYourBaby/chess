{
  "name": "stream-pkg",
  "author": {
    "name": "changchang",
    "email": "changchang005@gmail.com"
  },
  "version": "0.0.4",
  "description": "A simple tool to compose package for stream based API, such as tcp socket.",
  "homepage": "https://github.com/changchang/seq-queue",
  "repository": {
    "type": "git",
    "url": "git@github.com:changchang/stream-pkg.git"
  },
  "dependencies": {},
  "devDependencies": {
    "mocha": ">=0.0.1",
    "should": ">=0.0.1"
  },
  "contributors": [
    {
      "name": "* Yongchang Zhou",
      "email": "changchang005@gmail.com"
    }
  ],
  "readme": "#Stream-pkg\n\nStream-pkg is a simple tool for packages that transfered on stream-based API. \n\nAs we known, stream API is a good thing of Node.js and we could compose different applications by stream-based API conventionally. And package may be splited into small chunks when it transfered on stream-based API such as socket. We have to recompose the chunks into package when we receive them. But we have to do some jobs to find out when we get enough data to recover the original package. \n\nStream-pkg add a simple header for each package and the header uses variable length to record the length of the package. The header contains several bytes. The highest bit of each byte indicates whether current byte is the last byte of the header. 0 for so and 1 for not. And the low 7 bits are the data of the length value. We can read the length of package from the header and then recover the package from the rest of data. And inside stream-pkg, we use a FSM to figure out when we should parse the header part and when we should parse the data part.\n\n##Installation\n```\nnpm install stream-pkg\n```\n\n##Usage\n``` javascript\nvar Composer = require('stream-pkg');\n\nvar src = 'Hello world.';\nvar comp = new Composer();\n// package to data\nvar res = comp.compose(src);\n\n// data to package\ncomp.on('data', function(data) {\n\tvar str = data.toString('utf-8');\n\tstr.should.equal(src);\n\tdone();\n});\ncomp.feed(res);\n``` \n\nAnd we can use stream-pkg in a socket-based echo server and client as below:\n\n###sever.js\n``` javascript\nvar net = require('net');\nvar Composer = require('stream-pkg');\n\nvar server = net.createServer(function(socket) {\n\n  var composer = new Composer();\n\n  composer.on('data', function(pkg) {\n    console.log('package receive: %j', pkg.toString());\n    socket.write(composer.compose(pkg));\n  });\n\n  socket.on('data', function(data) {\n    composer.feed(data);\n  });\n\n  socket.on('end', function(data) {\n    composer.feed(data);\n    socket.end();\n    server.close();\n  });\n});\n\nserver.listen(8888);\n```\n\n###client.js\n``` javascript\nvar net = require('net');\nvar Composer = require('stream-pkg');\n\nvar client = net.connect({port: 8888});\n\nvar composer = new Composer();\nvar count = 3;\nvar src = 'hello world!';\nvar revCount = 0;\n\ncomposer.on('data', function(pkg) {\n  if(pkg.toString() === src) {\n    console.log('ok');\n  } else {\n    console.log('fail');\n  }\n\n  revCount++;\n\n  if(revCount >= count) {\n    client.end();\n  }\n});\n\nclient.on('data', function(data) {\n  composer.feed(data);\n});\n\nfor(var i=0; i<count; i++) {\n\tclient.write(composer.compose(src));\n}\n```\n\n##API\n###composer.compose(pkg)\nCompose package into byte data. \n####Arguments\n+ pkg - String or Buffer. Package data.\n+ return - Buffer that fill with package data.\n\n###composer.feed(data, [offset], [end])\nFeed data into composer. \n####Arguments\n+ data - Buffer. Next chunnk of data receive from stream. \n+ offset - Number. Optional. Offset index of buffer that start to feed. Default is 0.\n+ end - Number. Optional. End index (not includ) of buffer that stop to feed. Default is data.length.\n\n##Event\n###'data'(pkg)\nEmit package by data event when the package has finished.\n###'length_limit'(composer, data, offset)\nEmit when the package exceeds the limit of package size.",
  "readmeFilename": "README.md",
  "_id": "stream-pkg@0.0.4",
  "_from": "stream-pkg@0.0.4"
}
